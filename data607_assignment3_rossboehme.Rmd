---
title: "DATA606-Assignment3"
author: "Ross Boehme"
date: "2023-02-10"
output: html_document
---

<!-- Assignment 3: Please deliver links to an R Markdown file (in GitHub and rpubs.com) with solutions to the problems below.  You may work in a small group, but please submit separately with names of all group participants in your submission. -->

Reading in FiveThirtyEight data, calling it "majors"
```{r}
majors <- read.csv('https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/recent-grads.csv')
```

Loading dplyr package for data manipulation and string package for string manipulation/regex
```{r}
library(dplyr)
library(stringr)
```


#1. Using the 173 majors listed in fivethirtyeight.comâ€™s College Majors dataset, provide code that identifies the majors that contain either "DATA" or "STATISTICS"
```{r}
majors %>% 
  filter(grepl('STATISTICS', Major) | grepl('DATA', Major))
```


#2 Write code that transforms the data below:
[1] "bell pepper"  "bilberry"     "blackberry"   "blood orange"
[5] "blueberry"    "cantaloupe"   "chili pepper" "cloudberry"  
[9] "elderberry"   "lime"         "lychee"       "mulberry"    
[13] "olive"        "salal berry"
#Into a format like this:
c("bell pepper", "bilberry", "blackberry", "blood orange", "blueberry", "cantaloupe", "chili pepper", "cloudberry", "elderberry", "lime", "lychee", "mulberry", "olive", "salal berry")

For this problem, I'm assuming the index-labeled fruit strings are an output from a df, as in this df I'll create named "fruit".

```{r}
fruit <- data.frame(price = c(1.50, 0.25, 0.30, 2.00, 0.15, 5.00, 1.00, 0.50, 0.60, 0.35, 0.75, 0.60, 0.10, 0.40),
                    name = c('bell pepper', ' bilberry', 'blackberry', 'blood orange', 'blueberry', 'cantaloupe', 'chili pepper', 'cloudberry', 'elderberry', 'lime', 'lychee', 'mulberry', 'olive' ,'salal berry'),
                    type = c('Berry','Berry','Berry','Citrus','Berry','Melon','Berry','Berry','Berry','Citrus','Berry','Berry','Stone','Berry'))
                    
```
  
In this scenario, the index-labeled fruit strings output would be generated by a call to the dataframe's relevant column, such as:
```{r}
fruit$name
```
Base R has a function as.vector which coerces its argument into a vector. I'll save the above output to a new variable, fruit_names, which contains this vector.
```{r}
fruit_names <- as.vector(fruit$name)
```

Now that my data frame's series is a stand-alone vector, I can transform it, for example, adding strings to each value using the paste function. 
```{r}
paste(fruit_names,"are delicious",sep=" ")
```

#3 Describe, in words, what these expressions will match:

For this exercise, I'm assuming we're using the fruit_names vector defined above. It includes: 'bell pepper', ' bilberry', 'blackberry', 'blood orange', 'blueberry', 'cantaloupe', 'chili pepper', 'cloudberry', 'elderberry', 'lime', 'lychee', 'mulberry', 'olive' ,'salal berry'


#3a (.)\1\1
- First, this code will not run since it's lacking quotes around the regex and there's only one blackslash before the backreference group number 1. But I'll analyze it assuming those two issues are fixed.
- Dot is wild card character. Since there's only one, it means "match any single character".
- Parentheses group parts of a regular expression, limiting matches to part of the regex. There's only one group in this instance.
- \\1\\1 means take that wildcard character and find where it repeats two more times (total of 3 times)
- If the regex was "(.)\\1\\1" it would find any single character in text which repeats 3 times

```{r}
#Corrected regex, which finds any single character which repeats 3 times, like 'aaa'
str_view('aaa bb c',"(.)\\1\\1") 
```
```{r}
#Doesn't produce anything since no text in fruit_names is a single #character repeating 3 times.
str_view(fruit_names,"(.)\\1\\1") 
```


#3b "(.)(.)\\2\\1"
- (.)(.) matches any two characters in text which are in one of two different groups
- \\2 backreferences the second group result
- \\1 backreferences the first group result
- To summarize, since the second group result is referenced before the first, this regex looks for group 2 characters which are followed by group 1 characters in the reverse order

```{r}
#Finds character group then character group reversed, like ' bb ', 'dddd', '1221', and 'abba'
str_view('aaa bb c dddd 1221 abba 1212',"(.)(.)\\2\\1")  
```
```{r}
#Within fruit_names text, matches p<eppe>r within "bell pepper" and "chili pepper"
str_view(fruit_names,"(.)(.)\\2\\1")  
```

#3c (..)\1
- First, this code will not run since it's lacking quotes around the regex and there's only one backslash before the backreference group number 1. But I'll analyze it assuming those two issues are fixed.
- (..) matches any two characters grouped together
- \\1 backreferences the first group result, looking for a repeat of that first group result
- To summarize, "(..)\\1" matches any two characters which repeat again such as 1212, abab, and dddd.

```{r}
#Finds character pair which repeats, like in the below dddd and 1212
str_view('aaa bb c dddd 1221 abba 1212',"(..)\\1")  
```
```{r}
#Within fruit_names text, matches s<alal> within "salal berry"
str_view(fruit_names,"(..)\\1")
```

#3d "(.).\\1.\\1"
- This is similar to 3a except with two gaps between a group which repeats three times. Such as ababa or a a a.

```{r}
#Within the below, views 1. "aba a" (greedily taking away from "ababa") and 2. "ddddd"
str_view('abca abcc cbaba ababa ddddd',"(.).\\1.\\1")  
```

```{r}
#Within fruit_names text, doesn't match anything
str_view(fruit_names,"(.).\\1.\\1")
```


#3e "(.)(.)(.).*\\3\\2\\1"
- This is similar to 3b except 1. The kleene star asterisk * matches the preceding wildcard . by 0 (optional) or more times and 2. This regex looks for three wildcards, with the first ... in reverse order to the second ...
- The kleene star asterisk * means there can be any number of characters between these 3 wildcards, whether 0 like abccba or 9 like abc123456789cba

```{r}
#The below R code views "abca abcc cba" and " ababa "
str_view('abca abcc cbaba ababa ddddd',"(.)(.)(.).*\\3\\2\\1")  
```
```{r}
#Within fruit_names text, doesn't view anything
str_view(fruit_names,"(.)(.)(.).*\\3\\2\\1")
```


#4 Construct regular expressions to match words that:
#4a Start and end with the same character.
Answer = "^(.)(.*\\1$)"

```{r}
#Vector to test. Should view "racecar", "dad", "stress", and "high".
test4a <- c('apple','banana','orange','blueberry','racecar','umbrella','dad','stress','high','church')
```

```{r}
#Passes check
str_view(test4a,"^(.)(.*\\1$)")
```

#4b Contain a repeated pair of letters (e.g. "church" contains "ch" repeated twice.)
Answer = "([A-Za-z][A-Za-z]).*\\1" 
<!-- Note I'd ideally use \w{2} (word character x2) instead of [A-Za-z][A-Za-z] but couldn't figure out why my R wasn't accepting it -- does it not apply in R? It exists in regex for other programming language -->

```{r}
#Vector to test. Should view <anan> from "banana" and "church"
test4a <- c('apple','banana','orange','blueberry','racecar','umbrella','dad','stress','high','church')
```

```{r}
#Passes check
str_view(test4a,"([A-Za-z][A-Za-z]).*\\1")
```

#4c Contain one letter repeated in at least three places (e.g. "eleven" contains three "e"s.)
Answer = "([A-Za-z]).*\\1.*\\1"

```{r}
#Vector to test. Should view "b<anana>" (three As) and "<stress>" (three Ss)
test4a <- c('apple','banana','orange','blueberry','racecar','umbrella','dad','stress','high','church')
```

```{r}
#Passes check
str_view(test4a,"([A-Za-z]).*\\1.*\\1")
```